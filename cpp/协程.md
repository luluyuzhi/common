为什么会有协程是轻量级线程的说法呢？因为协程具有中断可恢复的特性，那么只需要在开一个全局的数组存储所有的协程，在协程中断时，不断轮转调用下一个协程继续运行即可； 这看起来似乎和线程无异，但其实有巨大的区别，**因为协程本质是函数，调用协程后原来的地方就会被阻塞，协程处理完了才返回结果，这是天然同步的**，而多线程无法做到这点，因为多线程的调度受内核控制，触发点来自于硬件时钟中断不可预见，同时又运行在多核心下，调用后运行次序是不确定的，想实现同步调用就必须通过std::promise/future 去辅佐，但为了性能往往见到的是异步+回调的方式进行多线程的交互，异步回调代码的可读性是很差的而且还需要考虑一大堆并发上锁的情况，**协程因其函数本质，是天然同步的，而在遇到阻塞条件时候，把cpu让给别的协程，等条件满足了再通过中断可恢复的特性再继续运行，就实现了并发，同步+并发就是协程强大的地方，其使用范式和轮转+同步非阻塞很像**



[1. 有栈协程与无栈协程](https://mthli.xyz/stackful-stackless/)

[2. 使用 C 语言实现协程](https://mthli.xyz/coroutines-in-c/)







