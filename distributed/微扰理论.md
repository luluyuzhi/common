写在前面
“面试造火箭，入职拧螺丝” 是小伙伴们常常吐槽算法面试的点。 但是良好的算法和数据结构基础和充分的算法训练，都会让我们在日常的开发中更游刃有余，并且很多算法在工作中也是比较常用的。比如这道题目的按权重随机选择。

随机选择在开发中是一个很常见的情况，不考虑来自业务的需求，在系统中，我们常常需要对分布式系统进行负载均衡。 一种策略就是按权重随机选择，权重含义很多，可能是机器的性能等等。
我本人在字节的工作中其实就是有写到这种代码的，当然工程中也会有一些优化，随机数的生成本身不是一个特别可靠的事情，一般能不用随机做负载均衡可能就会更倾向于其他方式，如一致性哈希。 我也准备出一个算法系列教程，主要侧重于算法在工程实践中的应用，感兴趣的可以在评论区留言哦。（代码可以写不好，但励志要当一个十项全能的UP主！）

言归正传！

解题思路 前缀和+二分搜索
题目意思非常简单，就是希望对数组的元素随机采样，出现的概率比例等于权重比例，用数组w表示。
相信学过概率论的同学很容易产生的思路就是，我们将权重摊平在一维直线上，然后从范围里随机采样一个值，落在哪个权重的范围里，就代表选出了哪个元素。具体见图。由于随机采样是均匀分布，所以每个元素被选中的概率就是 range_i / total_range。

![image.png](../source/img/1630288768-vMXiXu-image.png)


图中三段，不同颜色的线段代表权重可能是3:1:1的三个元素，我们将他们拼在一起。用随机函数在范围内采样，得到两个点，灰星就代表这次选择了绿色元素，黄星代表选择了红色元素。

我们随机之后如何确定选择了哪个范围呢，直接遍历或者二分查找就行啦。

```c++
class Solution {
private:
    mt19937 gen;
    uniform_int_distribution<int> dis;
    vector<int> pre;

public:
    Solution(vector<int>& w): gen(random_device{}()), dis(1, accumulate(w.begin(), w.end(), 0)) {
        partial_sum(w.begin(), w.end(), back_inserter(pre));
    }
int pickIndex() {
    int x = dis(gen);
    return lower_bound(pre.begin(), pre.end(), x) - pre.begin();
}    
};
```


复杂度分析

时间复杂度：初始化的时间复杂度为 O(n)O(n)，每次选择的时间复杂度为 O(\log n)O(logn)，其中 nn 是数组 ww 的长度。

空间复杂度：O(n)，即为前缀和数组 pre 需要使用的空间。
